#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
#define MAX 1000001
int dp[MAX] = { 0 };

int main() {
    int n;
    cin >> n;
    vector<int> v(n + 1);

    for (int i = 1; i <= n; i++) {
        cin >> v[i];
    }

    for (int i = 0; i <= n; i++) {
        dp[i] = 1;
    }

    int answer = 1;
    for (int i = n - 1; i >= 1; i--) {
        int j = i + 1;
        while (j <= n) {

            if (v[i] < v[j]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
            j++;
        }
        answer = max(answer, dp[i]);
    }

    cout << answer << "\n";

    return 0;
}


//count 가 안되는 경우 바로 앞에 정렬되어있는 숫자가 중복되어있고 그 사이에 들어갔을 때만 영향 x
//10 10 20 20 30 50
//
//10 20 30 50
//1   2   3  4
//
////이렇게 인덱스 정렬 해 두고, 어떤 인덱스로 들어가는지 확인한다.
//10 20 20 30 30 40 60 60 60 70 //10개
//1   2  2  3  3  4  5  5  5  6 //원래 최대값은 6 
//1    2     2   1     3     1
//이렇게 되어있겠지 ?
//바뀐 수열을
//
//10 20 20 30 30 40 60 60 60 70
//- (10) - (40) - (70)
//30 20 60 20 40 30 70 60 60 10 //10개
//3  2  5  2  4  3  6  5  5  1 //최대값이 3 why?
//
//원래 정렬된 형태에서 바뀐거다, 어떻게 바뀌었는지에 따라 최대값에서 감소시킨다.
//
//10 20 40 20 30 40 50 60
//find_Number
//large_Number
//count_largetNumber
//answer
//
//1 2 2 3 4 5 6 8
//
//1   2  3  4  5  6  8
//[1][2][1][1][0][0][1]
//
//6 5 2 4 8 2 3 1
//와야할 수보다 차이가 났다 ? 고려해보야함
//{
//	large number가 1 인게 젤 먼저와야한다, 그런데 다른게 온다 ? , 더 큰수가 온다는 뜻인데  그럴때 어떻게 해야할까
//	1. 만약에 큰수가 뒤에 하나 더 있다면 그냥 pass 한다.
//	- 기회가 한번 더 있기 때문이다.
//	- 문제는 앞에있는 큰 수를 선택하는게 더 이득인 경우가 존재한다는 것이다.
//	// 10 25 26 27 28 20 25 30 40 50 26 27 28 29
//	- 그럼 앞에있는 큰 수를 선택하는게 더 이득인지는 어떻게 알까 ? count 배열을 확인했을 때,
//	-해당 큰수보다 더 큰수들이
//
//	뒤에 똑같은 수가 더있는가 ? pass // 근데 pass 하면 선택을 안함으로서 얻게되는 패널티는?
//	차이가 2이상 난다->포기
//	차이가 1이다->선택


	//find_Number와 Large_Number 사이에 수가 1개 존재한다 ?


//와야할 수보다 2차이가 났다 & 뒤에 차이가 나 있는 수가 없다.
//그 수와 똑같은 수가 뒤에 하나 더 있다->pass
//아니다->answer--
//
//
//1. 3이 앞에 옴, 3은 뒤에 하나 더 있으므로 상관없음  식 check[3]--
//2. 2이 앞에 옴  2은 뒤에 하나 더 있으므로 상관없음  식 check[2]--
//3. 6이 앞에 옴  6은 뒤에 2개 더 있으므로 상관없음 식 check[5]--
//
//4. 2이 앞에 옴  2은 하나밖에 없는데 1보다 앞에온 상황임, check[2]--, answer--
//5. 4가 앞에 옴 4는 하나밖에 없는데 1, 3 보다 앞에 온 상황임 check[4]--, answer--
//6. 3이 앞에 옴 3은 하나밖에 없는다 1보다 앞에 온 상황임 check[3]--, answer--
//7. 6이 앞에 옴 6은 하나밖에 없는데 1, 5보다 앞에 온 상황임 check[5]--answer--

// 1 2 3 4 5

// 1 2 2 3 4 2 5 //정렬된 상태에서 차이가 1 인 인덱스의 num이 중복된 자신의 숫자 사이에 왔을 때만 count 에 영향이 없다.


//1이 와야할 자리인데 3이옴, 뒤에 1이 여러개고 3이 여러개라면 okay 1--, 3-- == 0 이므로 count--, 1은 이제 없음 2를 찾음, 3은 하나 남음 3을 선택하지 않음
//2가 와야할 자리에 2가 있음 pass, 이제 2는 영향이 없는 수
//3이 와야하는데 5가있음 5--, 3-- 함 3==0 임 count --


//1와야하는데 3이 있음, 차이가 2이상임 -> count--, 1은 넘어감 다음에 1이 오나? 남아있는1이 0개이기 때문에 이제 2를찾아야함
//2와야하는데 2가있음 pass ,2-- : 1 2는 이제 신경안써도 되는 수
//3와야하는데 5가있음, 차이가 2이상임 -> count--, 3-- 0됨, 5-- 2됨, 이제 4 찾아야 함
//4와야하는데 2가있음 2는 이미 찾았으니 pass
//4와야하는데 4가있음 pass 4찾음
//5를 찾아야 하는데 3이있음, 3은 count0임, 그리고 4를 이미 찾음 
//5를 찾아야 하는데 6이있음 5--, 6-- 6:0 임 count--
//5를찾아야하는데 5가있음 pass

//count가 줄어드는 이유가, 둘중 하나를 포기해야 하기 때문임, 근데 둘다 포기안해도된다면?
//포기안해도 되는 경우는 이런거 숫자가 중복되어있어서 여러개인거임! 그게 index 로 차이가 1인 경우고 중복 둘 다 남아있는 경우임!

